<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8">
<title>Spacing Trainer 1D</title>
<style>
  body {
    margin: 0;
    background: #1a1a1a;
    overflow: hidden;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    user-select: none;
    color: white;
  }
  canvas {
    display: block;
  }
  #ui {
    position: absolute;
    top: 20px;
    left: 0;
    width: 100%;
    text-align: center;
    pointer-events: none;
  }
  .key {
    background: #333;
    padding: 2px 6px;
    border-radius: 4px;
    border: 1px solid #555;
    font-weight: bold;
    font-family: monospace;
  }
</style>
</head>
<body>

<div id="ui">
  <h1 style="margin: 0; font-size: 24px;">SPACING DUEL</h1>
  <div style="margin-top: 10px; font-size: 16px;">
    Hareket: <span class="key">Sağ Tık (Mouse)</span>
    &nbsp;|&nbsp; 
    Menzil: <span class="key" id="range-key-display">A</span>
    &nbsp;|&nbsp; 
    Saldırı: <span class="key">Rakibe Sol Tık</span>
  </div>
  <div id="status" style="margin-top: 20px; font-size: 18px; color: #aaa;">Hazır ol...</div>
  <div id="score-display" style="margin-top: 5px; font-size: 16px; color: #8cf;">Skor: 0</div>
  <div id="level-display" style="margin-top: 2px; font-size: 14px; color: #8cf; opacity: 0.8;">Seviye: 1</div>
  <div style="margin-top: 5px; font-size: 12px; opacity: 0.7;">Rakip menziline girmeden onu vur!</div>
  
  <!-- Settings Button -->
  <button id="settings-btn" style="pointer-events: auto; margin-top: 15px; cursor: pointer; background: #333; color: #ddd; border: 1px solid #555; padding: 5px 12px; border-radius: 4px; font-family: inherit;">Ayarlar</button>
</div>

<!-- Settings Modal -->
<div id="settings-modal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #222; padding: 25px; border: 1px solid #555; border-radius: 8px; text-align: center; z-index: 100; box-shadow: 0 4px 20px rgba(0,0,0,0.5);">
  <h3 style="margin-top: 0; color: #fff;">Tuş Ayarları</h3>
  <div style="margin-bottom: 20px; color: #ddd;">
    Menzil Gösterge Tuşu: <button id="rebind-btn" class="key" style="cursor: pointer; font-size: 16px;">A</button>
  </div>
  
  <h3 style="margin-top: 0; color: #fff;">Zorluk Seviyesi</h3>
  <div style="margin-bottom: 20px; color: #ddd;">
    <button id="lvl1-btn" class="key" style="cursor: pointer; font-size: 16px; background: #4f8; color: #111; border-color: #4f8;">SEVİYE 1</button>
    <button id="lvl2-btn" class="key" style="cursor: pointer; font-size: 16px; margin-left: 10px;">SEVİYE 2</button>
  </div>

  <h3 style="margin-top: 0; color: #fff;">Oyun Modu</h3>
  <div style="margin-bottom: 20px; color: #ddd;">
    <button id="mode-normal-btn" class="key" style="cursor: pointer; font-size: 16px; background: #4f8; color: #111; border-color: #4f8;">NORMAL</button>
    <button id="mode-ahri-btn" class="key" style="cursor: pointer; font-size: 16px; margin-left: 10px;">AHRI DODGE</button>
  </div>

  <button id="close-settings" style="cursor: pointer; padding: 6px 16px; background: #444; color: white; border: none; border-radius: 4px;">Kapat</button>
</div>

<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

// ---------------- STATE (GLOBAL) ----------------
let cw, ch; // Canvas width/height
let player = { x: 0, y: 0, targetX: 0, targetY: 0, color: "#4f8" };
let enemy = { x: 0, y: 0, color: "#f44" };
let gameState = "start"; // start, playing, lose
let keys = {};
let keyBindings = { range: 'a' };
let isRebinding = false;
let playerAttackTimer = 0;
let enemyAttackTimer = 0;
let score = 0;
let currentLevel = 1;
let frameCount = 0;
let lastHitFrame = -9999;
let enemyWasInPlayerRange = false;
let enemyPatrolDirection = 1;
let patrolZoneMin = 0;
let patrolZoneMax = 0;
let tooFarTimer = 0;
let laneStart = { x: 0, y: 0 };
let laneEnd = { x: 0, y: 0 };
let gameMode = "normal"; // normal, ahri_dodge
let lastTime = 0;
let ahriOrb = { active: false, x: 0, y: 0, targetX: 0, targetY: 0, returnTarget: null, state: 'out', radius: 15 };

// ---------------- DOM ELEMENTS ----------------
const uiStatus = document.getElementById("status");
const scoreDisplay = document.getElementById("score-display");
const levelDisplay = document.getElementById("level-display");
const settingsBtn = document.getElementById("settings-btn");
const settingsModal = document.getElementById("settings-modal");
const rebindBtn = document.getElementById("rebind-btn");
const lvl1Btn = document.getElementById("lvl1-btn");
const lvl2Btn = document.getElementById("lvl2-btn");
const modeNormalBtn = document.getElementById("mode-normal-btn");
const modeAhriBtn = document.getElementById("mode-ahri-btn");
const closeSettingsBtn = document.getElementById("close-settings");
const rangeKeyDisplay = document.getElementById("range-key-display");

// ---------------- CONFIG ----------------
const PLAYER_RANGE = 210;
const ENEMY_RANGE = 160;
const PLAYER_SPEED = 400; // px per second
const ENEMY_SPEED = 240; // px per second
const ORB_SPEED = 500; // px per second
const TOO_FAR_MARGIN = 80;
const TOO_FAR_FRAMES = 2.5; // seconds
const MISSED_OPPORTUNITY_GRACE_FRAMES = 0.4; // seconds
const PATROL_ZONE_MIN_RATIO = 0.35;
const PATROL_ZONE_MAX_RATIO = 0.65;
const LANE_WIDTH = 180; // Width of the lane (vertical offset from center)

// ---------------- EVENT LISTENERS (UI) ----------------
settingsBtn.addEventListener("click", () => {
  settingsModal.style.display = "block";
});
closeSettingsBtn.addEventListener("click", () => {
  settingsModal.style.display = "none";
  isRebinding = false;
  rebindBtn.innerText = keyBindings.range.toUpperCase();
});
rebindBtn.addEventListener("click", () => {
  isRebinding = true;
  rebindBtn.innerText = "...";
});

lvl1Btn.addEventListener("click", () => {
  currentLevel = 1;
  updateLevelUI();
  resetGame();
});

lvl2Btn.addEventListener("click", () => {
  currentLevel = 2;
  updateLevelUI();
  resetGame();
});

modeNormalBtn.addEventListener("click", () => {
  gameMode = "normal";
  updateModeUI();
  resetGame();
});

modeAhriBtn.addEventListener("click", () => {
  gameMode = "ahri_dodge";
  updateModeUI();
  resetGame();
});

function updateLevelUI() {
  if (levelDisplay) levelDisplay.innerText = "Seviye: " + currentLevel + " | Mod: " + (gameMode === "normal" ? "Normal" : "Ahri Dodge");
  
  if (currentLevel === 1) {
    lvl1Btn.style.background = "#4f8";
    lvl1Btn.style.color = "#111";
    lvl1Btn.style.borderColor = "#4f8";
    lvl2Btn.style.background = "#333";
    lvl2Btn.style.color = "#ddd";
    lvl2Btn.style.borderColor = "#555";
  } else {
    lvl2Btn.style.background = "#f44";
    lvl2Btn.style.color = "#111";
    lvl2Btn.style.borderColor = "#f44";
    lvl1Btn.style.background = "#333";
    lvl1Btn.style.color = "#ddd";
    lvl1Btn.style.borderColor = "#555";
  }
}

function updateModeUI() {
  updateLevelUI(); // Refresh text
  
  if (gameMode === "normal") {
    modeNormalBtn.style.background = "#4f8";
    modeNormalBtn.style.color = "#111";
    modeNormalBtn.style.borderColor = "#4f8";
    modeAhriBtn.style.background = "#333";
    modeAhriBtn.style.color = "#ddd";
    modeAhriBtn.style.borderColor = "#555";
  } else {
    modeAhriBtn.style.background = "#48f"; // Blue for Ahri
    modeAhriBtn.style.color = "#fff";
    modeAhriBtn.style.borderColor = "#48f";
    modeNormalBtn.style.background = "#333";
    modeNormalBtn.style.color = "#ddd";
    modeNormalBtn.style.borderColor = "#555";
  }
}

// Init UI
updateModeUI();

function resize() {
  cw = canvas.width = window.innerWidth;
  ch = canvas.height = window.innerHeight;
  
  // Define Lane (Diagonal from bottom-left to top-right)
  // Roughly start near bottom-left, end near top-right
  laneStart = { x: 0, y: ch * 0.85 };
  laneEnd = { x: cw, y: ch * 0.15 };
  
  if (gameState === "start") resetGame();
}
window.addEventListener("resize", resize);

function getLaneY(x) {
  // Linear interpolation: y = mx + c
  // m = (y2 - y1) / (x2 - x1)
  const t = x / cw; // Normalized 0..1 assuming lane spans full width
  return laneStart.y + (laneEnd.y - laneStart.y) * t;
}

function clampToLane(x, y) {
  // Clamp X to screen
  const cx = Math.max(0, Math.min(cw, x));
  
  // Calculate center Y for this X
  const cy = getLaneY(cx);
  
  // Clamp Y within lane width
  const minY = cy - LANE_WIDTH;
  const maxY = cy + LANE_WIDTH;
  const clampedY = Math.max(minY, Math.min(maxY, y));
  
  return { x: cx, y: clampedY };
}

// ---------------- INPUT (GAME) ----------------
// Mouse Movement & Attack
window.addEventListener("mousedown", e => {
  if (gameState !== "playing") return;

  // Right Click (2) -> Move
  if (e.button === 2) {
      // Allow 2D movement within lane
      const clamped = clampToLane(e.clientX, e.clientY);
      
      player.targetX = clamped.x;
      player.targetY = clamped.y;
  }

  // Left Click (0) -> ATTACK if clicked on Enemy
  if (e.button === 0) {
    // Check if clicked on enemy (with generous hitbox)
    const distMouse = Math.hypot(e.clientX - enemy.x, e.clientY - enemy.y);
    if (distMouse <= 50) { // 20 radius + 30 padding
       tryAttack();
    }
  }
});

// Prevent context menu on right click
window.addEventListener("contextmenu", e => {
  e.preventDefault();
  // Movement handled in mousedown
});

window.addEventListener("keydown", e => {
  // Rebinding Logic
  if (isRebinding) {
    keyBindings.range = e.key.toLowerCase();
    rebindBtn.innerText = e.key.toUpperCase();
    rangeKeyDisplay.innerText = e.key.toUpperCase();
    isRebinding = false;
    return;
  }

  keys[e.key.toLowerCase()] = true;
  
  // Restart
  if (gameState !== "playing" && e.code === "Space") {
    resetGame();
    return;
  }
});

window.addEventListener("keyup", e => {
  keys[e.key.toLowerCase()] = false;
});

// ---------------- LOGIC ----------------
function resetGame() {
  if (currentLevel === 1) {
    patrolZoneMin = cw * PATROL_ZONE_MIN_RATIO;
    patrolZoneMax = cw * PATROL_ZONE_MAX_RATIO;
  } else {
    // Level 2: Narrower patrol zone
    const center = 0.5;
    const halfWidth = 0.075;
    patrolZoneMin = cw * (center - halfWidth);
    patrolZoneMax = cw * (center + halfWidth);
  }

  player.x = cw * 0.2;
  player.y = getLaneY(player.x);
  player.targetX = player.x;
  player.targetY = player.y;
  
  enemy.x = patrolZoneMin;
  enemy.y = getLaneY(enemy.x);
  
  ahriOrb.active = false;
  
  enemyPatrolDirection = 1;
  gameState = "playing";
  uiStatus.innerText = "Dövüş Başladı!";
  uiStatus.style.color = "white";
  playerAttackTimer = 0;
  enemyAttackTimer = 1.0; // Initial delay for Ahri Q
  score = 0;
  frameCount = 0;
  lastHitFrame = -9999;
  enemyWasInPlayerRange = false;
  tooFarTimer = 0;
  lastTime = performance.now();
}

function tryAttack() {
  if (playerAttackTimer > 0) return;
  
  playerAttackTimer = 0.25; // seconds (was 15 frames)
  const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
  
  if (dist <= PLAYER_RANGE) {
    score++;
    // lastHitFrame is less useful with dt, but we can use time or just increment
  }
}

function loseGame(reason) {
  gameState = "lose";
  uiStatus.innerText = "KAYBETTİN: " + reason;
  uiStatus.style.color = "#f44";
}

function updateAI(dt) {
  const moveStep = ENEMY_SPEED * dt;
  enemy.x += moveStep * enemyPatrolDirection;
  
  if (enemy.x >= patrolZoneMax) {
    enemyPatrolDirection = -1;
    enemy.x = patrolZoneMax;
  } else if (enemy.x <= patrolZoneMin) {
    enemyPatrolDirection = 1;
    enemy.x = patrolZoneMin;
  }
  
  // Update Y based on lane
  enemy.y = getLaneY(enemy.x);

  // Ahri Q Logic
  if (gameMode === "ahri_dodge") {
      if (ahriOrb.active) {
          const orbStep = ORB_SPEED * dt;
          
          if (ahriOrb.state === 'out') {
              const dx = ahriOrb.targetX - ahriOrb.x;
              const dy = ahriOrb.targetY - ahriOrb.y;
              const dist = Math.hypot(dx, dy);
              
              if (dist < orbStep) {
                  ahriOrb.x = ahriOrb.targetX;
                  ahriOrb.y = ahriOrb.targetY;
                  ahriOrb.state = 'return';
              } else {
                  ahriOrb.x += (dx / dist) * orbStep;
                  ahriOrb.y += (dy / dist) * orbStep;
              }
          } else if (ahriOrb.state === 'return') {
              const dx = enemy.x - ahriOrb.x;
              const dy = enemy.y - ahriOrb.y;
              const dist = Math.hypot(dx, dy);
              
              if (dist < orbStep) {
                  ahriOrb.active = false;
                  enemyAttackTimer = 1.0; // Cooldown
              } else {
                  ahriOrb.x += (dx / dist) * orbStep;
                  ahriOrb.y += (dy / dist) * orbStep;
              }
          }
          
          // Collision
          const distPlayer = Math.hypot(player.x - ahriOrb.x, player.y - ahriOrb.y);
          if (distPlayer < 20 + ahriOrb.radius) { // Player radius approx 20
              loseGame("Ahri Q'suna yakalandın!");
          }
      } else {
          if (enemyAttackTimer > 0) {
              enemyAttackTimer -= dt;
          } else {
              ahriOrb.active = true;
              ahriOrb.x = enemy.x;
              ahriOrb.y = enemy.y;
              ahriOrb.state = 'out';
              ahriOrb.targetX = player.x;
              ahriOrb.targetY = player.y;
              
              // Extend target slightly to ensure it crosses player pos? 
              // Ahri Q goes to target point. If player stands still, it hits.
          }
      }
  }

  const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
  if (dist <= ENEMY_RANGE) {
    loseGame("Rakip menziline girdi!");
  }
}

function update(dt) {
  if (gameState !== "playing") return;

  // Player Move (2D movement)
  const dx = player.targetX - player.x;
  const dy = player.targetY - player.y;
  const distMove = Math.hypot(dx, dy);
  const step = PLAYER_SPEED * dt;
  
  if (distMove > step) {
    player.x += (dx / distMove) * step;
    player.y += (dy / distMove) * step;
  } else {
    player.x = player.targetX;
    player.y = player.targetY;
  }
  
  // Ensure player stays in lane (extra safety)
  const clamped = clampToLane(player.x, player.y);
  player.x = clamped.x;
  player.y = clamped.y;

  // AI Move
  updateAI(dt);

  const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
  const inPlayerRange = dist <= PLAYER_RANGE;

  enemyWasInPlayerRange = inPlayerRange;

  if (playerAttackTimer > 0) playerAttackTimer -= dt;
  if (scoreDisplay) scoreDisplay.innerText = "Skor: " + score;
}

// ---------------- RENDER ----------------
function draw() {
  // BG
  ctx.fillStyle = "#1a1a1a";
  ctx.fillRect(0, 0, cw, ch);
  
  // Draw Diagonal Lane
  ctx.save();
  ctx.beginPath();
  
  ctx.moveTo(0, laneStart.y - LANE_WIDTH);
  ctx.lineTo(cw, laneEnd.y - LANE_WIDTH);
  ctx.lineTo(cw, laneEnd.y + LANE_WIDTH);
  ctx.lineTo(0, laneStart.y + LANE_WIDTH);
  ctx.closePath();
  
  ctx.fillStyle = "rgba(40, 40, 50, 0.5)";
  ctx.fill();
  
  ctx.strokeStyle = "#444";
  ctx.lineWidth = 2;
  
  // Draw center line
  ctx.beginPath();
  ctx.moveTo(laneStart.x, laneStart.y);
  ctx.lineTo(laneEnd.x, laneEnd.y);
  ctx.setLineDash([10, 20]);
  ctx.strokeStyle = "#333";
  ctx.stroke();
  ctx.setLineDash([]);
  
  // Draw borders
  ctx.beginPath();
  ctx.moveTo(0, laneStart.y - LANE_WIDTH);
  ctx.lineTo(cw, laneEnd.y - LANE_WIDTH);
  ctx.strokeStyle = "#555";
  ctx.stroke();
  
  ctx.beginPath();
  ctx.moveTo(0, laneStart.y + LANE_WIDTH);
  ctx.lineTo(cw, laneEnd.y + LANE_WIDTH);
  ctx.stroke();
  
  ctx.restore();

  // Patrol zone (rakibin devriye alanı) - visualized on the lane
  if (patrolZoneMax > patrolZoneMin) {
    const pMinY = getLaneY(patrolZoneMin);
    const pMaxY = getLaneY(patrolZoneMax);
    
    ctx.fillStyle = "rgba(255, 80, 80, 0.08)";
    // Polygon for patrol zone
    ctx.beginPath();
    ctx.moveTo(patrolZoneMin, pMinY - LANE_WIDTH);
    ctx.lineTo(patrolZoneMax, pMaxY - LANE_WIDTH);
    ctx.lineTo(patrolZoneMax, pMaxY + LANE_WIDTH);
    ctx.lineTo(patrolZoneMin, pMinY + LANE_WIDTH);
    ctx.fill();
    
    // Vertical markers for patrol limits? No, just the colored zone is enough
  }

  // Draw Movement Target
  if (gameState === "playing" && (Math.abs(player.x - player.targetX) > 5)) {
    ctx.strokeStyle = "rgba(100, 255, 100, 0.5)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(player.targetX, player.targetY - 10);
    ctx.lineTo(player.targetX, player.targetY + 10);
    ctx.moveTo(player.targetX - 5, player.targetY + 5);
    ctx.lineTo(player.targetX, player.targetY + 10);
    ctx.lineTo(player.targetX + 5, player.targetY + 5);
    ctx.stroke();
  }
  
  // Enemy Entity
  ctx.beginPath();
  ctx.arc(enemy.x, enemy.y, 20, 0, Math.PI*2);
  ctx.fillStyle = enemy.color;
  ctx.fill();
  
  // Ahri Orb
  if (gameMode === "ahri_dodge" && ahriOrb.active) {
    ctx.beginPath();
    ctx.arc(ahriOrb.x, ahriOrb.y, ahriOrb.radius, 0, Math.PI*2);
    ctx.fillStyle = "#0ff"; // Cyan
    ctx.shadowBlur = 10;
    ctx.shadowColor = "#0ff";
    ctx.fill();
    ctx.shadowBlur = 0;
  }
  
  // Player Entity
  ctx.beginPath();
  ctx.arc(player.x, player.y, 20, 0, Math.PI*2);
  ctx.fillStyle = player.color;
  ctx.fill();
  
  // Player Attack Visual
  if (keys[keyBindings.range] || playerAttackTimer > 0) {
    ctx.fillStyle = playerAttackTimer > 0 ? "rgba(100, 255, 100, 0.3)" : "rgba(100, 255, 100, 0.05)";
    ctx.beginPath();
    ctx.arc(player.x, player.y, PLAYER_RANGE, 0, Math.PI*2);
    ctx.fill();
    
    if (playerAttackTimer > 0) {
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 2;
        ctx.stroke();
    }
    
    ctx.strokeStyle = "rgba(100, 255, 100, 0.8)";
    ctx.setLineDash([5, 5]);
    ctx.beginPath();
    ctx.arc(player.x, player.y, PLAYER_RANGE, 0, Math.PI*2);
    ctx.stroke();
    ctx.setLineDash([]);
  }
  
  // Lose Screen
  if (gameState === "lose") {
    ctx.fillStyle = "rgba(0,0,0,0.5)";
    ctx.fillRect(0, 0, cw, ch);
    ctx.fillStyle = "#fff";
    ctx.font = "bold 32px Arial";
    ctx.fillText("MAĞLUBİYET", cw/2, ch/2 - 40);
    ctx.font = "18px Arial";
    ctx.fillText("Skor: " + score, cw/2, ch/2);
    ctx.font = "16px Arial";
    ctx.fillText("Yeniden başlamak için SPACE tuşuna bas", cw/2, ch/2 + 30);
  }
}

// Loop
function gameLoop(timestamp) {
  if (!lastTime) lastTime = timestamp;
  const dt = (timestamp - lastTime) / 1000;
  lastTime = timestamp;
  
  // Cap dt
  const safeDt = Math.min(dt, 0.1);

  update(safeDt);
  draw();
  requestAnimationFrame(gameLoop);
}

resize();
requestAnimationFrame(gameLoop);

</script>
</body>
</html>
