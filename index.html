<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8">
<title>Spacing Trainer 1D</title>
<style>
  body {
    margin: 0;
    background: #1a1a1a;
    overflow: hidden;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    user-select: none;
    color: white;
  }
  canvas {
    display: block;
  }
  #ui {
    position: absolute;
    top: 20px;
    left: 0;
    width: 100%;
    text-align: center;
    pointer-events: none;
  }
  .key {
    background: #333;
    padding: 2px 6px;
    border-radius: 4px;
    border: 1px solid #555;
    font-weight: bold;
    font-family: monospace;
  }
</style>
</head>
<body>

<div id="ui">
  <h1 style="margin: 0; font-size: 24px;">SPACING DUEL</h1>
  <div style="margin-top: 10px; font-size: 16px;">
    Hareket: <span class="key">Sağ Tık</span>
    &nbsp;|&nbsp; 
    Skiller: <span class="key">Q</span> / <span class="key">W</span>
    &nbsp;|&nbsp; 
    Menzil: <span class="key" id="range-key-display">A</span>
  </div>
  <div id="status" style="margin-top: 20px; font-size: 18px; color: #aaa;">Hazır ol...</div>
  <div id="score-display" style="margin-top: 5px; font-size: 16px; color: #8cf;">Skor: 0</div>
  <div id="level-display" style="margin-top: 2px; font-size: 14px; color: #8cf; opacity: 0.8;">Seviye: 1</div>
  <div style="margin-top: 5px; font-size: 12px; opacity: 0.7;">Rakip menziline girmeden onu vur!</div>
  
  <!-- Settings Button -->
  <button id="settings-btn" style="pointer-events: auto; margin-top: 15px; cursor: pointer; background: #333; color: #ddd; border: 1px solid #555; padding: 5px 12px; border-radius: 4px; font-family: inherit;">Ayarlar</button>
</div>

<!-- Settings Modal -->
<div id="settings-modal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #222; padding: 25px; border: 1px solid #555; border-radius: 8px; text-align: center; z-index: 100; box-shadow: 0 4px 20px rgba(0,0,0,0.5);">
  <h3 style="margin-top: 0; color: #fff;">Tuş Ayarları</h3>
  <div style="margin-bottom: 20px; color: #ddd;">
    Menzil Gösterge Tuşu: <button id="rebind-btn" class="key" style="cursor: pointer; font-size: 16px;">A</button>
  </div>
  
  <h3 style="margin-top: 0; color: #fff;">Zorluk Seviyesi</h3>
  <div style="margin-bottom: 20px; color: #ddd;">
    <button id="lvl1-btn" class="key" style="cursor: pointer; font-size: 16px; background: #4f8; color: #111; border-color: #4f8;">SEVİYE 1</button>
    <button id="lvl2-btn" class="key" style="cursor: pointer; font-size: 16px; margin-left: 10px;">SEVİYE 2</button>
  </div>

  <h3 style="margin-top: 0; color: #fff;">Oyun Modu</h3>
  <div style="margin-bottom: 20px; color: #ddd;">
    <button id="mode-normal-btn" class="key" style="cursor: pointer; font-size: 16px; background: #4f8; color: #111; border-color: #4f8;">NORMAL</button>
    <button id="mode-ahri-btn" class="key" style="cursor: pointer; font-size: 16px; margin-left: 10px;">AHRI DODGE</button>
  </div>

  <h3 style="margin-top: 0; color: #fff;">Ekstra Özellikler</h3>
  <div style="margin-bottom: 20px; color: #ddd;">
    <button id="minion-mode-btn" class="key" style="cursor: pointer; font-size: 16px; background: #333; color: #ddd; border-color: #555;">MİNYONLAR: KAPALI</button>
  </div>

  <button id="close-settings" style="cursor: pointer; padding: 6px 16px; background: #444; color: white; border: none; border-radius: 4px;">Kapat</button>
</div>

<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

// ---------------- STATE (GLOBAL) ----------------
let cw, ch; // Canvas width/height
let player = { x: 0, y: 0, targetX: 0, targetY: 0, color: "#4f8" };
let enemy = { x: 0, y: 0, color: "#f44" };
let gameState = "start"; // start, playing, lose
let keys = {};
let keyBindings = { range: 'a' };
let isRebinding = false;
let playerAttackTimer = 0;
let enemyAttackTimer = 0;
let score = 0;
let currentLevel = 1;
let frameCount = 0;
let lastHitFrame = -9999;
let enemyWasInPlayerRange = false;
let enemyPatrolDirection = 1;
let patrolZoneMin = 0;
let patrolZoneMax = 0;
let tooFarTimer = 0;
let laneStart = { x: 0, y: 0 };
let laneEnd = { x: 0, y: 0 };
let gameMode = "normal"; // normal, ahri_dodge
let minionMode = false;
let lastTime = 0;
let ahriOrb = { active: false, warning: false, warningTimer: 0, x: 0, y: 0, targetX: 0, targetY: 0, returnTarget: null, state: 'out', radius: 15 };
let minions = [];
let playerProjectiles = [];
let wEffects = []; // New: Brand W effects
let playerQCooldown = 0;
let playerWCooldown = 0; // New: W cooldown
let minionSpawnTimer = 0;
let missedMinions = 0; // Counter for missed minions in Ahri Dodge mode
const MAX_MISSED_MINIONS = 3;

// ---------------- DOM ELEMENTS ----------------
const uiStatus = document.getElementById("status");
const scoreDisplay = document.getElementById("score-display");
const levelDisplay = document.getElementById("level-display");
const settingsBtn = document.getElementById("settings-btn");
const settingsModal = document.getElementById("settings-modal");
const rebindBtn = document.getElementById("rebind-btn");
const lvl1Btn = document.getElementById("lvl1-btn");
const lvl2Btn = document.getElementById("lvl2-btn");
const modeNormalBtn = document.getElementById("mode-normal-btn");
const modeAhriBtn = document.getElementById("mode-ahri-btn");
const minionModeBtn = document.getElementById("minion-mode-btn");
const closeSettingsBtn = document.getElementById("close-settings");
const rangeKeyDisplay = document.getElementById("range-key-display");

// ---------------- CONFIG ----------------
const PLAYER_RANGE = 210;
const ENEMY_RANGE = 160;
const PLAYER_SPEED = 400; // px per second
const ENEMY_SPEED = 240; // px per second
const ORB_SPEED = 500; // px per second
const PROJECTILE_SPEED = 600; // px per second
const MINION_SPEED = 100; // px per second
const MINION_SPAWN_RATE = 7.5; // seconds (7-8s average)
const PLAYER_Q_COOLDOWN = 0.5; // seconds
const PLAYER_W_COOLDOWN = 3.0; // seconds for W
const Q_DAMAGE = 300;
const W_DAMAGE = 300;
const W_RADIUS = 90;
const W_DELAY = 0.6; // Brand W delay
const MINION_MAX_HP = 500;
const MINION_PASSIVE_DAMAGE = 100; // per second
const TOO_FAR_MARGIN = 80;
const TOO_FAR_FRAMES = 2.5; // seconds
const MISSED_OPPORTUNITY_GRACE_FRAMES = 0.4; // seconds
const PATROL_ZONE_MIN_RATIO = 0.35;
const PATROL_ZONE_MAX_RATIO = 0.65;
let LANE_WIDTH = 180; // Width of the lane (vertical offset from center)

// ---------------- EVENT LISTENERS (UI) ----------------
settingsBtn.addEventListener("click", () => {
  settingsModal.style.display = "block";
});
closeSettingsBtn.addEventListener("click", () => {
  settingsModal.style.display = "none";
  isRebinding = false;
  rebindBtn.innerText = keyBindings.range.toUpperCase();
});
rebindBtn.addEventListener("click", () => {
  isRebinding = true;
  rebindBtn.innerText = "...";
});

lvl1Btn.addEventListener("click", () => {
  currentLevel = 1;
  updateLevelUI();
  resetGame();
});

lvl2Btn.addEventListener("click", () => {
  currentLevel = 2;
  updateLevelUI();
  resetGame();
});

modeNormalBtn.addEventListener("click", () => {
  gameMode = "normal";
  updateModeUI();
  resetGame();
});

modeAhriBtn.addEventListener("click", () => {
  gameMode = "ahri_dodge";
  updateModeUI();
  resetGame();
});

minionModeBtn.addEventListener("click", () => {
  minionMode = !minionMode;
  updateModeUI();
  resetGame();
});

function updateLevelUI() {
  if (levelDisplay) {
    let text = "Seviye: " + currentLevel + " | Mod: " + (gameMode === "normal" ? "Normal" : "Ahri Dodge");
    if (minionMode) {
      text += " + Minyonlar";
      if (gameMode === "ahri_dodge") {
        text += " | Kaçan: " + missedMinions + "/" + MAX_MISSED_MINIONS;
      }
    }
    levelDisplay.innerText = text;
  }
  
  if (currentLevel === 1) {
    lvl1Btn.style.background = "#4f8";
    lvl1Btn.style.color = "#111";
    lvl1Btn.style.borderColor = "#4f8";
    lvl2Btn.style.background = "#333";
    lvl2Btn.style.color = "#ddd";
    lvl2Btn.style.borderColor = "#555";
  } else {
    lvl2Btn.style.background = "#f44";
    lvl2Btn.style.color = "#111";
    lvl2Btn.style.borderColor = "#f44";
    lvl1Btn.style.background = "#333";
    lvl1Btn.style.color = "#ddd";
    lvl1Btn.style.borderColor = "#555";
  }
}

function updateModeUI() {
  updateLevelUI(); // Refresh text
  
  if (gameMode === "normal") {
    modeNormalBtn.style.background = "#4f8";
    modeNormalBtn.style.color = "#111";
    modeNormalBtn.style.borderColor = "#4f8";
    modeAhriBtn.style.background = "#333";
    modeAhriBtn.style.color = "#ddd";
    modeAhriBtn.style.borderColor = "#555";
  } else {
    modeAhriBtn.style.background = "#48f"; // Blue for Ahri
    modeAhriBtn.style.color = "#fff";
    modeAhriBtn.style.borderColor = "#48f";
    modeNormalBtn.style.background = "#333";
    modeNormalBtn.style.color = "#ddd";
    modeNormalBtn.style.borderColor = "#555";
  }
  
  if (minionMode) {
      minionModeBtn.style.background = "#4f8";
      minionModeBtn.style.color = "#111";
      minionModeBtn.style.borderColor = "#4f8";
      minionModeBtn.innerText = "MİNYONLAR: AÇIK";
  } else {
      minionModeBtn.style.background = "#333";
      minionModeBtn.style.color = "#ddd";
      minionModeBtn.style.borderColor = "#555";
      minionModeBtn.innerText = "MİNYONLAR: KAPALI";
  }
}

// Init UI
updateModeUI();

function resize() {
  cw = canvas.width = window.innerWidth;
  ch = canvas.height = window.innerHeight;
  
  // Define Lane (Diagonal from bottom-left to top-right)
  // Roughly start near bottom-left, end near top-right
  laneStart = { x: 0, y: ch * 0.85 };
  laneEnd = { x: cw, y: ch * 0.15 };
  
  if (gameMode === "ahri_dodge") {
      LANE_WIDTH = 180 * 1.15; // 15% wider
  } else {
      LANE_WIDTH = 180;
  }
  
  if (gameState === "start") resetGame();
}
window.addEventListener("resize", resize);

function getLaneY(x) {
  // Linear interpolation: y = mx + c
  // m = (y2 - y1) / (x2 - x1)
  const t = x / cw; // Normalized 0..1 assuming lane spans full width
  return laneStart.y + (laneEnd.y - laneStart.y) * t;
}

function clampToLane(x, y) {
  // Clamp X to screen
  const cx = Math.max(0, Math.min(cw, x));
  
  // Calculate center Y for this X
  const cy = getLaneY(cx);
  
  // Clamp Y within lane width
  const minY = cy - LANE_WIDTH;
  const maxY = cy + LANE_WIDTH;
  const clampedY = Math.max(minY, Math.min(maxY, y));
  
  return { x: cx, y: clampedY };
}

// ---------------- INPUT (GAME) ----------------
// Mouse Movement & Attack
window.addEventListener("mousedown", e => {
  if (gameState !== "playing") return;

  // Right Click (2) -> Move
  if (e.button === 2) {
      // Allow 2D movement within lane
      const clamped = clampToLane(e.clientX, e.clientY);
      
      player.targetX = clamped.x;
      player.targetY = clamped.y;
  }

  // Left Click (0) -> ATTACK if clicked on Enemy
  if (e.button === 0) {
    // Check if clicked on enemy (with generous hitbox)
    const distMouse = Math.hypot(e.clientX - enemy.x, e.clientY - enemy.y);
    if (distMouse <= 50) { // 20 radius + 30 padding
       tryAttack();
    }
  }
});

// Prevent context menu on right click
window.addEventListener("contextmenu", e => {
  e.preventDefault();
  // Movement handled in mousedown
});

window.addEventListener("keydown", e => {
  // Q Skillshot
  if (minionMode && gameState === "playing" && e.key.toLowerCase() === 'q') {
      tryFireProjectile();
  }
  
  // W AoE Skill (Brand W)
  if (minionMode && gameState === "playing" && e.key.toLowerCase() === 'w') {
      tryFireW();
  }

  // Rebinding Logic
  if (isRebinding) {
    keyBindings.range = e.key.toLowerCase();
    rebindBtn.innerText = e.key.toUpperCase();
    rangeKeyDisplay.innerText = e.key.toUpperCase();
    isRebinding = false;
    return;
  }

  keys[e.key.toLowerCase()] = true;
  
  // Restart
  if (gameState !== "playing" && e.code === "Space") {
    resetGame();
    return;
  }
});

window.addEventListener("keyup", e => {
  keys[e.key.toLowerCase()] = false;
});

// ---------------- LOGIC ----------------
function resetGame() {
  if (gameMode === "ahri_dodge") {
    // Ahri mode: Far right (end of diagonal), wider patrol zone
    // Lane goes 0 to cw.
    // Center 0.85, width significantly increased
    const center = 0.68; 
    const halfWidth = 0.14; // Increased from 0.08 to 0.15
    patrolZoneMin = cw * (center - halfWidth);
    patrolZoneMax = cw * (center + halfWidth);
    missedMinions = 0; // Reset missed counter
  } else if (currentLevel === 1) {
    patrolZoneMin = cw * PATROL_ZONE_MIN_RATIO;
    patrolZoneMax = cw * PATROL_ZONE_MAX_RATIO;
  } else {
    // Level 2: Narrower patrol zone
    const center = 0.5;
    const halfWidth = 0.075;
    patrolZoneMin = cw * (center - halfWidth);
    patrolZoneMax = cw * (center + halfWidth);
  }

  player.x = cw * 0.2;
  player.y = getLaneY(player.x);
  player.targetX = player.x;
  player.targetY = player.y;
  
  enemy.x = patrolZoneMin;
  enemy.y = getLaneY(enemy.x);
  
  ahriOrb.active = false;
  ahriOrb.warning = false;
  minions = [];
  playerProjectiles = [];
  wEffects = [];
  playerQCooldown = 0;
  playerWCooldown = 0;
  minionSpawnTimer = 0;
  
  enemyPatrolDirection = 1;
  gameState = "playing";
  uiStatus.innerText = "Dövüş Başladı!";
  uiStatus.style.color = "white";
  playerAttackTimer = 0;
  enemyAttackTimer = 1.0; // Initial delay for Ahri Q
  score = 0;
  frameCount = 0;
  lastHitFrame = -9999;
  enemyWasInPlayerRange = false;
  tooFarTimer = 0;
  lastTime = performance.now();
  
  // Update lane width based on mode
  resize();
}

function tryFireProjectile() {
    if (playerQCooldown > 0) return;
    
    // Fire projectile towards mouse? No, usually skillshots go towards mouse.
    // We need mouse position. Let's track it or just use a stored value.
    // For now, let's assume it shoots towards the enemy side of the lane if no mouse tracking.
    // BUT user said "bizim qmüz düz mermi olsun".
    // Ideally it should go towards mouse.
    // Since we don't have mouse pos in keydown, let's track it globally.
}
// Add mouse tracking
let mouseX = 0;
let mouseY = 0;
window.addEventListener("mousemove", e => {
    mouseX = e.clientX;
    mouseY = e.clientY;
});

// Redefine tryFireProjectile with mouse pos
function tryFireProjectile() {
    if (playerQCooldown > 0) return;
    
    playerQCooldown = PLAYER_Q_COOLDOWN;
    
    const dx = mouseX - player.x;
    const dy = mouseY - player.y;
    const mag = Math.hypot(dx, dy);
    
    playerProjectiles.push({
        x: player.x,
        y: player.y,
        vx: (dx / mag) * PROJECTILE_SPEED,
        vy: (dy / mag) * PROJECTILE_SPEED,
        radius: 8,
        damage: Q_DAMAGE,
        active: true
    });
}

function tryFireW() {
    if (playerWCooldown > 0) return;
    
    playerWCooldown = PLAYER_W_COOLDOWN;
    
    wEffects.push({
        x: mouseX,
        y: mouseY,
        timer: W_DELAY,
        radius: W_RADIUS,
        damage: W_DAMAGE,
        exploded: false,
        active: true
    });
}

function tryAttack() {
  if (playerAttackTimer > 0) return;
  
  playerAttackTimer = 0.25; // seconds (was 15 frames)
  const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
  
  if (dist <= PLAYER_RANGE) {
    score++;
    // lastHitFrame is less useful with dt, but we can use time or just increment
  }
}

function loseGame(reason) {
  gameState = "lose";
  uiStatus.innerText = "KAYBETTİN: " + reason;
  uiStatus.style.color = "#f44";
}

function updateAI(dt) {
  // Speed boost in Ahri mode
  let speed = ENEMY_SPEED;
  if (gameMode === "ahri_dodge") {
      speed *= 2.0; // Much faster side-to-side
  }

  const moveStep = speed * dt;
  enemy.x += moveStep * enemyPatrolDirection;
  
  if (enemy.x >= patrolZoneMax) {
    enemyPatrolDirection = -1;
    enemy.x = patrolZoneMax;
  } else if (enemy.x <= patrolZoneMin) {
    enemyPatrolDirection = 1;
    enemy.x = patrolZoneMin;
  }
  
  // Update Y based on lane
  enemy.y = getLaneY(enemy.x);

  // Ahri Q Logic
  if (gameMode === "ahri_dodge") {
      if (ahriOrb.active) {
          const orbStep = ORB_SPEED * dt;
          
          if (ahriOrb.state === 'out') {
              const dx = ahriOrb.targetX - ahriOrb.x;
              const dy = ahriOrb.targetY - ahriOrb.y;
              const dist = Math.hypot(dx, dy);
              
              if (dist < orbStep) {
                  ahriOrb.x = ahriOrb.targetX;
                  ahriOrb.y = ahriOrb.targetY;
                  ahriOrb.state = 'return';
              } else {
                  ahriOrb.x += (dx / dist) * orbStep;
                  ahriOrb.y += (dy / dist) * orbStep;
              }
          } else if (ahriOrb.state === 'return') {
              const dx = enemy.x - ahriOrb.x;
              const dy = enemy.y - ahriOrb.y;
              const dist = Math.hypot(dx, dy);
              
              if (dist < orbStep) {
                  ahriOrb.active = false;
                  enemyAttackTimer = 1.0; // Reset timer
                  ahriOrb.warning = false; // Reset warning
              } else {
                  ahriOrb.x += (dx / dist) * orbStep;
                  ahriOrb.y += (dy / dist) * orbStep;
              }
          }
          
          // Collision
          const distPlayer = Math.hypot(player.x - ahriOrb.x, player.y - ahriOrb.y);
          if (distPlayer < 20 + ahriOrb.radius) { // Player radius approx 20
              loseGame("Ahri Q'suna yakalandın!");
          }
          
          // Minion Collision with Ahri Q (Ahri's Q destroys minions if they reach it/it reaches them?)
          // User said: "buna ahrinin menziline ulaştıklarında kayboldukları... dahil edilecek"
          // This implies minions disappearing when they reach Ahri/Q max range, NOT Ahri Q killing them.
          // BUT: "q yediğinde can barı yarıya düşsün hani 2qda ölüyorlar ya 2.qta yok olcaklar zaten"
          // This refers to PLAYER Q. "biz öldürmeden yok olurlarsa" -> Minions reaching destination.
      } else {
          // Cooldown phase
          if (enemyAttackTimer > 0) {
              enemyAttackTimer -= dt;
              
              const MAX_Q_RANGE = cw * 0.45; // Max range limit

              // Warning phase (last 1 second)
              if (enemyAttackTimer <= 1.0) {
                   if (!ahriOrb.warning) {
                       ahriOrb.warning = true;
                   }
                   
                   // Calculate potential target
                   let dx = player.x - enemy.x;
                   let dy = player.y - enemy.y;
                   let dist = Math.hypot(dx, dy);
                   
                   // Clamp to MAX_Q_RANGE
                   if (dist > MAX_Q_RANGE) {
                       let ratio = MAX_Q_RANGE / dist;
                       ahriOrb.targetX = enemy.x + dx * ratio;
                       ahriOrb.targetY = enemy.y + dy * ratio;
                   } else {
                       ahriOrb.targetX = player.x;
                       ahriOrb.targetY = player.y;
                   }
              }
          } else {
              ahriOrb.active = true;
              ahriOrb.warning = false;
              ahriOrb.x = enemy.x;
              ahriOrb.y = enemy.y;
              ahriOrb.state = 'out';
              // Target already set in warning phase
          }
      }
  }

  // Minion Logic
  if (minionMode) {
      minionSpawnTimer -= dt;
      if (minionSpawnTimer <= 0) {
          minionSpawnTimer = MINION_SPAWN_RATE;
          
          // Spawn minion wave (2 or 3)
          const waveSize = Math.floor(Math.random() * 2) + 2; // Randomly 2 or 3

          for (let i = 0; i < waveSize; i++) {
              // Logic: "ahrinin biraz daha solundan gelsin" -> Left of Patrol Zone Min
              // Use patrolZoneMin as reference if in Ahri mode, else use laneEnd
              
              let baseSpawnX;
              if (gameMode === "ahri_dodge") {
                  baseSpawnX = patrolZoneMin - 50; // 50px left of Ahri's area
              } else {
                  baseSpawnX = laneEnd.x;
              }

              // Stagger them slightly in X so they don't overlap perfectly if Y is similar
              // or just to make them look like a group
              const offsetX = i * 30; 
              const spawnX = baseSpawnX + offsetX;
              
              const spawnYCenter = getLaneY(spawnX);
              
              minions.push({
                  x: spawnX,
                  y: spawnYCenter + (Math.random() * LANE_WIDTH * 1.5 - LANE_WIDTH * 0.75), // Random Y in lane
                  hp: MINION_MAX_HP,
                  maxHp: MINION_MAX_HP,
                  radius: 12,
                  active: true
              });
          }
      }
      
      // Update Minions
      for (let i = minions.length - 1; i >= 0; i--) {
          let m = minions[i];
          
          // Eğer minyon zaten pasifse (oyuncu öldürdüyse) listeden çıkar ve devam et
          if (!m.active) {
              minions.splice(i, 1);
              continue;
          }

          const laneDx = laneStart.x - laneEnd.x;
          const laneDy = laneStart.y - laneEnd.y;
          const laneLen = Math.hypot(laneDx, laneDy);
          
          m.x += (laneDx / laneLen) * MINION_SPEED * dt;
          m.y += (laneDy / laneLen) * MINION_SPEED * dt;
          
          // Passive damage (100 per second)
          m.hp -= MINION_PASSIVE_DAMAGE * dt;
          
          if (m.hp <= 0) {
              m.active = false;
              loseGame("Minyonu zamanında öldüremedin!");
              continue;
          }

          // Check if missed (reached far left)
          if (m.x < 50) { 
             m.active = false;
             loseGame("Minyon hattı yardı!");
             continue;
          }
      }
      
      // Update W Effects
      if (playerWCooldown > 0) playerWCooldown -= dt;
      for (let i = wEffects.length - 1; i >= 0; i--) {
          let w = wEffects[i];
          w.timer -= dt;
          
          if (w.timer <= 0 && !w.exploded) {
              w.exploded = true;
              // Check collision with minions
              for (let m of minions) {
                  if (!m.active) continue;
                  const dist = Math.hypot(w.x - m.x, w.y - m.y);
                  if (dist < w.radius + m.radius) {
                      m.hp -= w.damage;
                      if (m.hp <= 0) {
                          m.active = false;
                          score += 10; // Bonus score for minion
                      }
                  }
              }
          }
          
          // Remove effect after explosion visual
          if (w.timer < -0.4) { // 0.4s for explosion visual
              wEffects.splice(i, 1);
          }
      }
      
      // Update Projectiles
      if (playerQCooldown > 0) playerQCooldown -= dt;
      
      for (let i = playerProjectiles.length - 1; i >= 0; i--) {
          let p = playerProjectiles[i];
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          
          // Collision with minions
          for (let m of minions) {
              if (!m.active) continue;
              const dist = Math.hypot(p.x - m.x, p.y - m.y);
              if (dist < p.radius + m.radius) {
                  m.hp -= p.damage;
                  if (m.hp <= 0) {
                      m.active = false;
                      score += 10; // Bonus score for minion
                  }
                  p.active = false;
                  break;
              }
          }
          
          if (p.x < 0 || p.x > cw || p.y < 0 || p.y > ch) p.active = false;
          
          if (!p.active) {
              playerProjectiles.splice(i, 1);
          }
      }
  }

  const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
  if (dist <= ENEMY_RANGE) {
    loseGame("Rakip menziline girdi!");
  }
}

function update(dt) {
  if (gameState !== "playing") return;

  // Player Move (2D movement)
  const dx = player.targetX - player.x;
  const dy = player.targetY - player.y;
  const distMove = Math.hypot(dx, dy);
  const step = PLAYER_SPEED * dt;
  
  if (distMove > step) {
    player.x += (dx / distMove) * step;
    player.y += (dy / distMove) * step;
  } else {
    player.x = player.targetX;
    player.y = player.targetY;
  }
  
  // Ensure player stays in lane (extra safety)
  const clamped = clampToLane(player.x, player.y);
  player.x = clamped.x;
  player.y = clamped.y;

  // AI Move
  updateAI(dt);

  const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
  const inPlayerRange = dist <= PLAYER_RANGE;

  enemyWasInPlayerRange = inPlayerRange;

  if (playerAttackTimer > 0) playerAttackTimer -= dt;
  if (scoreDisplay) scoreDisplay.innerText = "Skor: " + score;
}

// ---------------- RENDER ----------------
function draw() {
  // BG
  ctx.fillStyle = "#1a1a1a";
  ctx.fillRect(0, 0, cw, ch);
  
  // Draw Diagonal Lane
  ctx.save();
  ctx.beginPath();
  
  ctx.moveTo(0, laneStart.y - LANE_WIDTH);
  ctx.lineTo(cw, laneEnd.y - LANE_WIDTH);
  ctx.lineTo(cw, laneEnd.y + LANE_WIDTH);
  ctx.lineTo(0, laneStart.y + LANE_WIDTH);
  ctx.closePath();
  
  ctx.fillStyle = "rgba(40, 40, 50, 0.5)";
  ctx.fill();
  
  ctx.strokeStyle = "#444";
  ctx.lineWidth = 2;
  
  // Draw center line
  ctx.beginPath();
  ctx.moveTo(laneStart.x, laneStart.y);
  ctx.lineTo(laneEnd.x, laneEnd.y);
  ctx.setLineDash([10, 20]);
  ctx.strokeStyle = "#333";
  ctx.stroke();
  ctx.setLineDash([]);
  
  // Draw borders
  ctx.beginPath();
  ctx.moveTo(0, laneStart.y - LANE_WIDTH);
  ctx.lineTo(cw, laneEnd.y - LANE_WIDTH);
  ctx.strokeStyle = "#555";
  ctx.stroke();
  
  ctx.beginPath();
  ctx.moveTo(0, laneStart.y + LANE_WIDTH);
  ctx.lineTo(cw, laneEnd.y + LANE_WIDTH);
  ctx.stroke();
  
  ctx.restore();

  // Patrol zone (rakibin devriye alanı) - visualized on the lane
  if (patrolZoneMax > patrolZoneMin) {
    const pMinY = getLaneY(patrolZoneMin);
    const pMaxY = getLaneY(patrolZoneMax);
    
    ctx.fillStyle = "rgba(255, 80, 80, 0.08)";
    // Polygon for patrol zone
    ctx.beginPath();
    ctx.moveTo(patrolZoneMin, pMinY - LANE_WIDTH);
    ctx.lineTo(patrolZoneMax, pMaxY - LANE_WIDTH);
    ctx.lineTo(patrolZoneMax, pMaxY + LANE_WIDTH);
    ctx.lineTo(patrolZoneMin, pMinY + LANE_WIDTH);
    ctx.fill();
    
    // Vertical markers for patrol limits? No, just the colored zone is enough
  }

  // Draw Movement Target
  if (gameState === "playing" && (Math.abs(player.x - player.targetX) > 5)) {
    ctx.strokeStyle = "rgba(100, 255, 100, 0.5)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(player.targetX, player.targetY - 10);
    ctx.lineTo(player.targetX, player.targetY + 10);
    ctx.moveTo(player.targetX - 5, player.targetY + 5);
    ctx.lineTo(player.targetX, player.targetY + 10);
    ctx.lineTo(player.targetX + 5, player.targetY + 5);
    ctx.stroke();
  }
  
  // Enemy Entity
  ctx.beginPath();
  ctx.arc(enemy.x, enemy.y, 20, 0, Math.PI*2);
  ctx.fillStyle = enemy.color;
  ctx.fill();
  
  // Ahri Orb Warning (Range Indicator)
  if (gameMode === "ahri_dodge" && ahriOrb.warning) {
      // Show range circle around Ahri
      const MAX_Q_RANGE = cw * 0.45; // Same as logic
      
      ctx.fillStyle = "rgba(0, 255, 255, 0.1)"; // Faint cyan fill
      ctx.beginPath();
      ctx.arc(enemy.x, enemy.y, MAX_Q_RANGE, 0, Math.PI*2);
      ctx.fill();
      
      ctx.strokeStyle = "rgba(0, 255, 255, 0.6)"; // Cyan border
      ctx.lineWidth = 2;
      ctx.setLineDash([10, 10]);
      ctx.stroke();
      ctx.setLineDash([]);

      // Optional: Show target line clamped to range
      if (ahriOrb.targetX) {
        ctx.strokeStyle = "rgba(255, 0, 0, 0.5)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(enemy.x, enemy.y);
        ctx.lineTo(ahriOrb.targetX, ahriOrb.targetY);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.arc(ahriOrb.targetX, ahriOrb.targetY, 5, 0, Math.PI*2);
        ctx.fillStyle = "red";
        ctx.fill();
      }
  }
  
  // Ahri Orb
  if (gameMode === "ahri_dodge" && ahriOrb.active) {
    ctx.beginPath();
    ctx.arc(ahriOrb.x, ahriOrb.y, ahriOrb.radius, 0, Math.PI*2);
    ctx.fillStyle = "#0ff"; // Cyan
    ctx.shadowBlur = 10;
    ctx.shadowColor = "#0ff";
    ctx.fill();
    ctx.shadowBlur = 0;
  }
  
  // Minions
  if (minionMode) {
      for (let m of minions) {
          // Minion Body
          ctx.beginPath();
          ctx.arc(m.x, m.y, m.radius, 0, Math.PI*2);
          ctx.fillStyle = "#ffaaaa";
          ctx.fill();
          ctx.strokeStyle = "#a33";
          ctx.lineWidth = 1;
          ctx.stroke();

          // HP Bar
          const barWidth = 30;
          const barHeight = 5;
          const barX = m.x - barWidth / 2;
          const barY = m.y - m.radius - 10;
          
          // Background
          ctx.fillStyle = "#333";
          ctx.fillRect(barX, barY, barWidth, barHeight);
          
          // Foreground
          const hpRatio = Math.max(0, m.hp / m.maxHp);
          ctx.fillStyle = hpRatio > 0.3 ? "#4f8" : "#f44";
          ctx.fillRect(barX, barY, barWidth * hpRatio, barHeight);
          
          // Border
          ctx.strokeStyle = "#000";
          ctx.lineWidth = 1;
          ctx.strokeRect(barX, barY, barWidth, barHeight);
      }
      
      // W Effects
      for (let w of wEffects) {
          if (!w.exploded) {
              // Pre-explosion indicator
              ctx.beginPath();
              ctx.arc(w.x, w.y, w.radius, 0, Math.PI * 2);
              ctx.strokeStyle = "rgba(255, 100, 0, 0.8)";
              ctx.setLineDash([5, 5]);
              ctx.lineWidth = 2;
              ctx.stroke();
              ctx.setLineDash([]);
              
              // Fill rising
              const fillRatio = 1 - (w.timer / W_DELAY);
              ctx.fillStyle = "rgba(255, 100, 0, 0.2)";
              ctx.beginPath();
              ctx.arc(w.x, w.y, w.radius * fillRatio, 0, Math.PI * 2);
              ctx.fill();
          } else {
              // Explosion visual
              const alpha = Math.max(0, 1 + w.timer * 2.5); // w.timer goes from 0 to -0.4
              ctx.fillStyle = `rgba(255, 150, 0, ${alpha})`;
              ctx.beginPath();
              ctx.arc(w.x, w.y, w.radius, 0, Math.PI * 2);
              ctx.fill();
              
              ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
              ctx.lineWidth = 3;
              ctx.stroke();
          }
      }
      
      // Projectiles
      for (let p of playerProjectiles) {
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.radius, 0, Math.PI*2);
          ctx.fillStyle = "#ffff00";
          ctx.fill();
      }
  }
  
  // Player Entity
  ctx.beginPath();
  ctx.arc(player.x, player.y, 20, 0, Math.PI*2);
  ctx.fillStyle = player.color;
  ctx.fill();
  
  // Player Attack Visual
  if (keys[keyBindings.range] || playerAttackTimer > 0) {
    ctx.fillStyle = playerAttackTimer > 0 ? "rgba(100, 255, 100, 0.3)" : "rgba(100, 255, 100, 0.05)";
    ctx.beginPath();
    ctx.arc(player.x, player.y, PLAYER_RANGE, 0, Math.PI*2);
    ctx.fill();
    
    if (playerAttackTimer > 0) {
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 2;
        ctx.stroke();
    }
    
    ctx.strokeStyle = "rgba(100, 255, 100, 0.8)";
    ctx.setLineDash([5, 5]);
    ctx.beginPath();
    ctx.arc(player.x, player.y, PLAYER_RANGE, 0, Math.PI*2);
    ctx.stroke();
    ctx.setLineDash([]);
  }
  
  // Lose Screen
  if (gameState === "lose") {
    ctx.fillStyle = "rgba(0,0,0,0.5)";
    ctx.fillRect(0, 0, cw, ch);
    ctx.fillStyle = "#fff";
    ctx.font = "bold 32px Arial";
    ctx.fillText("MAĞLUBİYET", cw/2, ch/2 - 40);
    ctx.font = "18px Arial";
    ctx.fillText("Skor: " + score, cw/2, ch/2);
    ctx.font = "16px Arial";
    ctx.fillText("Yeniden başlamak için SPACE tuşuna bas", cw/2, ch/2 + 30);
  }
}

// Loop
function gameLoop(timestamp) {
  if (!lastTime) lastTime = timestamp;
  const dt = (timestamp - lastTime) / 1000;
  lastTime = timestamp;
  
  // Cap dt
  const safeDt = Math.min(dt, 0.1);

  update(safeDt);
  draw();
  requestAnimationFrame(gameLoop);
}

resize();
requestAnimationFrame(gameLoop);

</script>
</body>
</html>
